{
  "version": 3,
  "sources": ["../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js", "../../use-sync-external-store/shim/index.js", "../../@preact/signals-core/src/index.ts", "../../@preact/signals-react/runtime/src/auto.ts", "../../@preact/signals-react/runtime/src/index.ts", "../../@preact/signals-react/src/index.ts"],
  "sourcesContent": ["/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = require('react');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n", "'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.min.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n", "function cycleDetected(): never {\n\tthrow new Error(\"Cycle detected\");\n}\nfunction mutationDetected(): never {\n\tthrow new Error(\"Computed cannot have side-effects\");\n}\n\nconst identifier = Symbol.for('preact-signals')\n\n// Flags for Computed and Effect.\nconst RUNNING = 1 << 0;\nconst NOTIFIED = 1 << 1;\nconst OUTDATED = 1 << 2;\nconst DISPOSED = 1 << 3;\nconst HAS_ERROR = 1 << 4;\nconst TRACKING = 1 << 5;\n\n// A linked list node used to track dependencies (sources) and dependents (targets).\n// Also used to remember the source's last version number that the target saw.\ntype Node = {\n\t// A source whose value the target depends on.\n\t_source: Signal;\n\t_prevSource?: Node;\n\t_nextSource?: Node;\n\n\t// A target that depends on the source and should be notified when the source changes.\n\t_target: Computed | Effect;\n\t_prevTarget?: Node;\n\t_nextTarget?: Node;\n\n\t// The version number of the source that target has last seen. We use version numbers\n\t// instead of storing the source value, because source values can take arbitrary amount\n\t// of memory, and computeds could hang on to them forever because they're lazily evaluated.\n\t// Use the special value -1 to mark potentially unused but recyclable nodes.\n\t_version: number;\n\n\t// Used to remember & roll back the source's previous `._node` value when entering &\n\t// exiting a new evaluation context.\n\t_rollbackNode?: Node;\n};\n\nfunction startBatch() {\n\tbatchDepth++;\n}\n\nfunction endBatch() {\n\tif (batchDepth > 1) {\n\t\tbatchDepth--;\n\t\treturn;\n\t}\n\n\tlet error: unknown;\n\tlet hasError = false;\n\n\twhile (batchedEffect !== undefined) {\n\t\tlet effect: Effect | undefined = batchedEffect;\n\t\tbatchedEffect = undefined;\n\n\t\tbatchIteration++;\n\n\t\twhile (effect !== undefined) {\n\t\t\tconst next: Effect | undefined = effect._nextBatchedEffect;\n\t\t\teffect._nextBatchedEffect = undefined;\n\t\t\teffect._flags &= ~NOTIFIED;\n\n\t\t\tif (!(effect._flags & DISPOSED) && needsToRecompute(effect)) {\n\t\t\t\ttry {\n\t\t\t\t\teffect._callback();\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (!hasError) {\n\t\t\t\t\t\terror = err;\n\t\t\t\t\t\thasError = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\teffect = next;\n\t\t}\n\t}\n\tbatchIteration = 0;\n\tbatchDepth--;\n\n\tif (hasError) {\n\t\tthrow error;\n\t}\n}\n\nfunction batch<T>(callback: () => T): T {\n\tif (batchDepth > 0) {\n\t\treturn callback();\n\t}\n\t/*@__INLINE__**/ startBatch();\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tendBatch();\n\t}\n}\n\n// Currently evaluated computed or effect.\nlet evalContext: Computed | Effect | undefined = undefined;\n\nlet untrackedDepth = 0;\n\nfunction untracked<T>(callback: () => T): T {\n\tif (untrackedDepth > 0) {\n\t\treturn callback();\n\t}\n\tconst prevContext = evalContext;\n\tevalContext = undefined;\n\tuntrackedDepth++;\n\ttry {\n\t\treturn callback();\n\t} finally {\n\t\tuntrackedDepth--;\n\t\tevalContext = prevContext;\n\t}\n}\n\n// Effects collected into a batch.\nlet batchedEffect: Effect | undefined = undefined;\nlet batchDepth = 0;\nlet batchIteration = 0;\n\n// A global version number for signals, used for fast-pathing repeated\n// computed.peek()/computed.value calls when nothing has changed globally.\nlet globalVersion = 0;\n\nfunction addDependency(signal: Signal): Node | undefined {\n\tif (evalContext === undefined) {\n\t\treturn undefined;\n\t}\n\n\tlet node = signal._node;\n\tif (node === undefined || node._target !== evalContext) {\n\t\t/**\n\t\t * `signal` is a new dependency. Create a new dependency node, and set it\n\t\t * as the tail of the current context's dependency list. e.g:\n\t\t *\n\t\t * { A <-> B       }\n\t\t *         ↑     ↑\n\t\t *        tail  node (new)\n\t\t *               ↓\n\t\t * { A <-> B <-> C }\n\t\t *               ↑\n\t\t *              tail (evalContext._sources)\n\t\t */\n\t\tnode = {\n\t\t\t_version: 0,\n\t\t\t_source: signal,\n\t\t\t_prevSource: evalContext._sources,\n\t\t\t_nextSource: undefined,\n\t\t\t_target: evalContext,\n\t\t\t_prevTarget: undefined,\n\t\t\t_nextTarget: undefined,\n\t\t\t_rollbackNode: node,\n\t\t};\n\n\t\tif (evalContext._sources !== undefined) {\n\t\t\tevalContext._sources._nextSource = node;\n\t\t}\n\t\tevalContext._sources = node;\n\t\tsignal._node = node;\n\n\t\t// Subscribe to change notifications from this dependency if we're in an effect\n\t\t// OR evaluating a computed signal that in turn has subscribers.\n\t\tif (evalContext._flags & TRACKING) {\n\t\t\tsignal._subscribe(node);\n\t\t}\n\t\treturn node;\n\t} else if (node._version === -1) {\n\t\t// `signal` is an existing dependency from a previous evaluation. Reuse it.\n\t\tnode._version = 0;\n\n\t\t/**\n\t\t * If `node` is not already the current tail of the dependency list (i.e.\n\t\t * there is a next node in the list), then make the `node` the new tail. e.g:\n\t\t *\n\t\t * { A <-> B <-> C <-> D }\n\t\t *         ↑           ↑\n\t\t *        node   ┌─── tail (evalContext._sources)\n\t\t *         └─────│─────┐\n\t\t *               ↓     ↓\n\t\t * { A <-> C <-> D <-> B }\n\t\t *                     ↑\n\t\t *                    tail (evalContext._sources)\n\t\t */\n\t\tif (node._nextSource !== undefined) {\n\t\t\tnode._nextSource._prevSource = node._prevSource;\n\n\t\t\tif (node._prevSource !== undefined) {\n\t\t\t\tnode._prevSource._nextSource = node._nextSource;\n\t\t\t}\n\n\t\t\tnode._prevSource = evalContext._sources;\n\t\t\tnode._nextSource = undefined;\n\n\t\t\tevalContext._sources!._nextSource = node;\n\t\t\tevalContext._sources = node;\n\t\t}\n\n\t\t// We can assume that the currently evaluated effect / computed signal is already\n\t\t// subscribed to change notifications from `signal` if needed.\n\t\treturn node;\n\t}\n\treturn undefined;\n}\n\n// @ts-ignore internal Signal is viewed as a function\ndeclare class Signal<T = any> {\n\t/** @internal */\n\t_value: unknown;\n\n\t/**\n\t * @internal\n\t * Version numbers should always be >= 0, because the special value -1 is used\n\t * by Nodes to signify potentially unused but recyclable nodes.\n\t */\n\t_version: number;\n\n\t/** @internal */\n\t_node?: Node;\n\n\t/** @internal */\n\t_targets?: Node;\n\n\tconstructor(value?: T);\n\n\t/** @internal */\n\t_refresh(): boolean;\n\n\t/** @internal */\n\t_subscribe(node: Node): void;\n\n\t/** @internal */\n\t_unsubscribe(node: Node): void;\n\n\tsubscribe(fn: (value: T) => void): () => void;\n\n\tvalueOf(): T;\n\n\ttoString(): string;\n\n\ttoJSON(): T;\n\n\tpeek(): T;\n\n\tbrand: typeof identifier;\n\n\tget value(): T;\n\tset value(value: T);\n}\n\n/** @internal */\n// @ts-ignore internal Signal is viewed as function\nfunction Signal(this: Signal, value?: unknown) {\n\tthis._value = value;\n\tthis._version = 0;\n\tthis._node = undefined;\n\tthis._targets = undefined;\n}\n\nSignal.prototype.brand = identifier\n\nSignal.prototype._refresh = function () {\n\treturn true;\n};\n\nSignal.prototype._subscribe = function (node) {\n\tif (this._targets !== node && node._prevTarget === undefined) {\n\t\tnode._nextTarget = this._targets;\n\t\tif (this._targets !== undefined) {\n\t\t\tthis._targets._prevTarget = node;\n\t\t}\n\t\tthis._targets = node;\n\t}\n};\n\nSignal.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the signal has any subscribers to begin with.\n\tif (this._targets !== undefined) {\n\t\tconst prev = node._prevTarget;\n\t\tconst next = node._nextTarget;\n\t\tif (prev !== undefined) {\n\t\t\tprev._nextTarget = next;\n\t\t\tnode._prevTarget = undefined;\n\t\t}\n\t\tif (next !== undefined) {\n\t\t\tnext._prevTarget = prev;\n\t\t\tnode._nextTarget = undefined;\n\t\t}\n\t\tif (node === this._targets) {\n\t\t\tthis._targets = next;\n\t\t}\n\t}\n};\n\nSignal.prototype.subscribe = function (fn) {\n\tconst signal = this;\n\treturn effect(function (this: Effect) {\n\t\tconst value = signal.value;\n\t\tconst flag = this._flags & TRACKING;\n\t\tthis._flags &= ~TRACKING;\n\t\ttry {\n\t\t\tfn(value);\n\t\t} finally {\n\t\t\tthis._flags |= flag;\n\t\t}\n\t});\n};\n\nSignal.prototype.valueOf = function () {\n\treturn this.value;\n};\n\nSignal.prototype.toString = function () {\n\treturn this.value + \"\";\n};\n\nSignal.prototype.toJSON = function () {\n\treturn this.value;\n};\n\nSignal.prototype.peek = function () {\n\treturn this._value;\n};\n\nObject.defineProperty(Signal.prototype, \"value\", {\n\tget() {\n\t\tconst node = addDependency(this);\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\treturn this._value;\n\t},\n\tset(this: Signal, value) {\n\t\tif (evalContext instanceof Computed) {\n\t\t\tmutationDetected();\n\t\t}\n\n\t\tif (value !== this._value) {\n\t\t\tif (batchIteration > 100) {\n\t\t\t\tcycleDetected();\n\t\t\t}\n\n\t\t\tthis._value = value;\n\t\t\tthis._version++;\n\t\t\tglobalVersion++;\n\n\t\t\t/**@__INLINE__*/ startBatch();\n\t\t\ttry {\n\t\t\t\tfor (\n\t\t\t\t\tlet node = this._targets;\n\t\t\t\t\tnode !== undefined;\n\t\t\t\t\tnode = node._nextTarget\n\t\t\t\t) {\n\t\t\t\t\tnode._target._notify();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tendBatch();\n\t\t\t}\n\t\t}\n\t},\n});\n\nfunction signal<T>(value: T): Signal<T> {\n\treturn new Signal(value);\n}\n\nfunction needsToRecompute(target: Computed | Effect): boolean {\n\t// Check the dependencies for changed values. The dependency list is already\n\t// in order of use. Therefore if multiple dependencies have changed values, only\n\t// the first used dependency is re-evaluated at this point.\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\t// If there's a new version of the dependency before or after refreshing,\n\t\t// or the dependency has something blocking it from refreshing at all (e.g. a\n\t\t// dependency cycle), then we need to recompute.\n\t\tif (\n\t\t\tnode._source._version !== node._version ||\n\t\t\t!node._source._refresh() ||\n\t\t\tnode._source._version !== node._version\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t// If none of the dependencies have changed values since last recompute then\n\t// there's no need to recompute.\n\treturn false;\n}\n\nfunction prepareSources(target: Computed | Effect) {\n\t/**\n\t * 1. Mark all current sources as re-usable nodes (version: -1)\n\t * 2. Set a rollback node if the current node is being used in a different context\n\t * 3. Point 'target._sources' to the tail of the doubly-linked list, e.g:\n\t *\n\t *    { undefined <- A <-> B <-> C -> undefined }\n\t *                   ↑           ↑\n\t *                   │           └──────┐\n\t * target._sources = A; (node is head)  │\n\t *                   ↓                  │\n\t * target._sources = C; (node is tail) ─┘\n\t */\n\tfor (\n\t\tlet node = target._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tconst rollbackNode = node._source._node;\n\t\tif (rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = rollbackNode;\n\t\t}\n\t\tnode._source._node = node;\n\t\tnode._version = -1;\n\n\t\tif (node._nextSource === undefined) {\n\t\t\ttarget._sources = node;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction cleanupSources(target: Computed | Effect) {\n\tlet node = target._sources;\n\tlet head = undefined;\n\n\t/**\n\t * At this point 'target._sources' points to the tail of the doubly-linked list.\n\t * It contains all existing sources + new sources in order of use.\n\t * Iterate backwards until we find the head node while dropping old dependencies.\n\t */\n\twhile (node !== undefined) {\n\t\tconst prev = node._prevSource;\n\n\t\t/**\n\t\t * The node was not re-used, unsubscribe from its change notifications and remove itself\n\t\t * from the doubly-linked list. e.g:\n\t\t *\n\t\t * { A <-> B <-> C }\n\t\t *         ↓\n\t\t *    { A <-> C }\n\t\t */\n\t\tif (node._version === -1) {\n\t\t\tnode._source._unsubscribe(node);\n\n\t\t\tif (prev !== undefined) {\n\t\t\t\tprev._nextSource = node._nextSource;\n\t\t\t}\n\t\t\tif (node._nextSource !== undefined) {\n\t\t\t\tnode._nextSource._prevSource = prev;\n\t\t\t}\n\t\t} else {\n\t\t\t/**\n\t\t\t * The new head is the last node seen which wasn't removed/unsubscribed\n\t\t\t * from the doubly-linked list. e.g:\n\t\t\t *\n\t\t\t * { A <-> B <-> C }\n\t\t\t *   ↑     ↑     ↑\n\t\t\t *   │     │     └ head = node\n\t\t\t *   │     └ head = node\n\t\t\t *   └ head = node\n\t\t\t */\n\t\t\thead = node;\n\t\t}\n\n\t\tnode._source._node = node._rollbackNode;\n\t\tif (node._rollbackNode !== undefined) {\n\t\t\tnode._rollbackNode = undefined;\n\t\t}\n\n\t\tnode = prev;\n\t}\n\n\ttarget._sources = head;\n}\n\ndeclare class Computed<T = any> extends Signal<T> {\n\t_compute: () => T;\n\t_sources?: Node;\n\t_globalVersion: number;\n\t_flags: number;\n\n\tconstructor(compute: () => T);\n\n\t_notify(): void;\n\tget value(): T;\n}\n\nfunction Computed(this: Computed, compute: () => unknown) {\n\tSignal.call(this, undefined);\n\n\tthis._compute = compute;\n\tthis._sources = undefined;\n\tthis._globalVersion = globalVersion - 1;\n\tthis._flags = OUTDATED;\n}\n\nComputed.prototype = new Signal() as Computed;\n\nComputed.prototype._refresh = function () {\n\tthis._flags &= ~NOTIFIED;\n\n\tif (this._flags & RUNNING) {\n\t\treturn false;\n\t}\n\n\t// If this computed signal has subscribed to updates from its dependencies\n\t// (TRACKING flag set) and none of them have notified about changes (OUTDATED\n\t// flag not set), then the computed value can't have changed.\n\tif ((this._flags & (OUTDATED | TRACKING)) === TRACKING) {\n\t\treturn true;\n\t}\n\tthis._flags &= ~OUTDATED;\n\n\tif (this._globalVersion === globalVersion) {\n\t\treturn true;\n\t}\n\tthis._globalVersion = globalVersion;\n\n\t// Mark this computed signal running before checking the dependencies for value\n\t// changes, so that the RUNNING flag can be used to notice cyclical dependencies.\n\tthis._flags |= RUNNING;\n\tif (this._version > 0 && !needsToRecompute(this)) {\n\t\tthis._flags &= ~RUNNING;\n\t\treturn true;\n\t}\n\n\tconst prevContext = evalContext;\n\ttry {\n\t\tprepareSources(this);\n\t\tevalContext = this;\n\t\tconst value = this._compute();\n\t\tif (\n\t\t\tthis._flags & HAS_ERROR ||\n\t\t\tthis._value !== value ||\n\t\t\tthis._version === 0\n\t\t) {\n\t\t\tthis._value = value;\n\t\t\tthis._flags &= ~HAS_ERROR;\n\t\t\tthis._version++;\n\t\t}\n\t} catch (err) {\n\t\tthis._value = err;\n\t\tthis._flags |= HAS_ERROR;\n\t\tthis._version++;\n\t}\n\tevalContext = prevContext;\n\tcleanupSources(this);\n\tthis._flags &= ~RUNNING;\n\treturn true;\n};\n\nComputed.prototype._subscribe = function (node) {\n\tif (this._targets === undefined) {\n\t\tthis._flags |= OUTDATED | TRACKING;\n\n\t\t// A computed signal subscribes lazily to its dependencies when the it\n\t\t// gets its first subscriber.\n\t\tfor (\n\t\t\tlet node = this._sources;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextSource\n\t\t) {\n\t\t\tnode._source._subscribe(node);\n\t\t}\n\t}\n\tSignal.prototype._subscribe.call(this, node);\n};\n\nComputed.prototype._unsubscribe = function (node) {\n\t// Only run the unsubscribe step if the computed signal has any subscribers.\n\tif (this._targets !== undefined) {\n\t\tSignal.prototype._unsubscribe.call(this, node);\n\n\t\t// Computed signal unsubscribes from its dependencies when it loses its last subscriber.\n\t\t// This makes it possible for unreferences subgraphs of computed signals to get garbage collected.\n\t\tif (this._targets === undefined) {\n\t\t\tthis._flags &= ~TRACKING;\n\n\t\t\tfor (\n\t\t\t\tlet node = this._sources;\n\t\t\t\tnode !== undefined;\n\t\t\t\tnode = node._nextSource\n\t\t\t) {\n\t\t\t\tnode._source._unsubscribe(node);\n\t\t\t}\n\t\t}\n\t}\n};\n\nComputed.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= OUTDATED | NOTIFIED;\n\n\t\tfor (\n\t\t\tlet node = this._targets;\n\t\t\tnode !== undefined;\n\t\t\tnode = node._nextTarget\n\t\t) {\n\t\t\tnode._target._notify();\n\t\t}\n\t}\n};\n\nComputed.prototype.peek = function () {\n\tif (!this._refresh()) {\n\t\tcycleDetected();\n\t}\n\tif (this._flags & HAS_ERROR) {\n\t\tthrow this._value;\n\t}\n\treturn this._value;\n};\n\nObject.defineProperty(Computed.prototype, \"value\", {\n\tget() {\n\t\tif (this._flags & RUNNING) {\n\t\t\tcycleDetected();\n\t\t}\n\t\tconst node = addDependency(this);\n\t\tthis._refresh();\n\t\tif (node !== undefined) {\n\t\t\tnode._version = this._version;\n\t\t}\n\t\tif (this._flags & HAS_ERROR) {\n\t\t\tthrow this._value;\n\t\t}\n\t\treturn this._value;\n\t},\n});\n\ninterface ReadonlySignal<T = any> extends Signal<T> {\n\treadonly value: T;\n}\n\nfunction computed<T>(compute: () => T): ReadonlySignal<T> {\n\treturn new Computed(compute);\n}\n\nfunction cleanupEffect(effect: Effect) {\n\tconst cleanup = effect._cleanup;\n\teffect._cleanup = undefined;\n\n\tif (typeof cleanup === \"function\") {\n\t\t/*@__INLINE__**/ startBatch();\n\n\t\t// Run cleanup functions always outside of any context.\n\t\tconst prevContext = evalContext;\n\t\tevalContext = undefined;\n\t\ttry {\n\t\t\tcleanup();\n\t\t} catch (err) {\n\t\t\teffect._flags &= ~RUNNING;\n\t\t\teffect._flags |= DISPOSED;\n\t\t\tdisposeEffect(effect);\n\t\t\tthrow err;\n\t\t} finally {\n\t\t\tevalContext = prevContext;\n\t\t\tendBatch();\n\t\t}\n\t}\n}\n\nfunction disposeEffect(effect: Effect) {\n\tfor (\n\t\tlet node = effect._sources;\n\t\tnode !== undefined;\n\t\tnode = node._nextSource\n\t) {\n\t\tnode._source._unsubscribe(node);\n\t}\n\teffect._compute = undefined;\n\teffect._sources = undefined;\n\n\tcleanupEffect(effect);\n}\n\nfunction endEffect(this: Effect, prevContext?: Computed | Effect) {\n\tif (evalContext !== this) {\n\t\tthrow new Error(\"Out-of-order effect\");\n\t}\n\tcleanupSources(this);\n\tevalContext = prevContext;\n\n\tthis._flags &= ~RUNNING;\n\tif (this._flags & DISPOSED) {\n\t\tdisposeEffect(this);\n\t}\n\tendBatch();\n}\n\ntype EffectCleanup = () => unknown;\ndeclare class Effect {\n\t_compute?: () => unknown | EffectCleanup;\n\t_cleanup?: () => unknown;\n\t_sources?: Node;\n\t_nextBatchedEffect?: Effect;\n\t_flags: number;\n\n\tconstructor(compute: () => unknown | EffectCleanup);\n\n\t_callback(): void;\n\t_start(): () => void;\n\t_notify(): void;\n\t_dispose(): void;\n}\n\nfunction Effect(this: Effect, compute: () => unknown | EffectCleanup) {\n\tthis._compute = compute;\n\tthis._cleanup = undefined;\n\tthis._sources = undefined;\n\tthis._nextBatchedEffect = undefined;\n\tthis._flags = TRACKING;\n}\n\nEffect.prototype._callback = function () {\n\tconst finish = this._start();\n\ttry {\n\t\tif (this._flags & DISPOSED) return;\n\t\tif (this._compute === undefined) return;\n\n\t\tconst cleanup = this._compute();\n\t\tif (typeof cleanup === \"function\") {\n\t\t\tthis._cleanup = cleanup as EffectCleanup;\n\t\t}\n\t} finally {\n\t\tfinish();\n\t}\n};\n\nEffect.prototype._start = function () {\n\tif (this._flags & RUNNING) {\n\t\tcycleDetected();\n\t}\n\tthis._flags |= RUNNING;\n\tthis._flags &= ~DISPOSED;\n\tcleanupEffect(this);\n\tprepareSources(this);\n\n\t/*@__INLINE__**/ startBatch();\n\tconst prevContext = evalContext;\n\tevalContext = this;\n\treturn endEffect.bind(this, prevContext);\n};\n\nEffect.prototype._notify = function () {\n\tif (!(this._flags & NOTIFIED)) {\n\t\tthis._flags |= NOTIFIED;\n\t\tthis._nextBatchedEffect = batchedEffect;\n\t\tbatchedEffect = this;\n\t}\n};\n\nEffect.prototype._dispose = function () {\n\tthis._flags |= DISPOSED;\n\n\tif (!(this._flags & RUNNING)) {\n\t\tdisposeEffect(this);\n\t}\n};\n\nfunction effect(compute: () => unknown | EffectCleanup): () => void {\n\tconst effect = new Effect(compute);\n\ttry {\n\t\teffect._callback();\n\t} catch (err) {\n\t\teffect._dispose();\n\t\tthrow err;\n\t}\n\t// Return a bound function instead of a wrapper like `() => effect._dispose()`,\n\t// because bound functions seem to be just as fast and take up a lot less memory.\n\treturn effect._dispose.bind(effect);\n}\n\nexport {\n\tsignal,\n\tcomputed,\n\teffect,\n\tbatch,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n};\n", "import {\n\t// @ts-ignore-next-line\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED as ReactInternals,\n} from \"react\";\nimport React from \"react\";\nimport jsxRuntime from \"react/jsx-runtime\";\nimport jsxRuntimeDev from \"react/jsx-dev-runtime\";\nimport { EffectStore, wrapJsx, _useSignalsImplementation } from \"./index\";\n\nexport interface ReactDispatcher {\n\tuseRef: typeof React.useRef;\n\tuseCallback: typeof React.useCallback;\n\tuseReducer: typeof React.useReducer;\n\tuseSyncExternalStore: typeof React.useSyncExternalStore;\n\tuseEffect: typeof React.useEffect;\n\tuseImperativeHandle: typeof React.useImperativeHandle;\n}\n\n// In order for signals to work in React, we need to observe what signals a\n// component uses while rendering. To do this, we need to know when a component\n// is rendering. To do this, we watch the transition of the\n// ReactCurrentDispatcher to know when a component is rerendering.\n//\n// To track when we are entering and exiting a component render (i.e. before and\n// after React renders a component), we track how the dispatcher changes.\n// Outside of a component rendering, the dispatcher is set to an instance that\n// errors or warns when any hooks are called. This behavior is prevents hooks\n// from being used outside of components. Right before React renders a\n// component, the dispatcher is set to an instance that doesn't warn or error\n// and contains the implementations of all hooks. Right after React finishes\n// rendering a component, the dispatcher is set to the erroring one again. This\n// erroring dispatcher is called the `ContextOnlyDispatcher` in React's source.\n//\n// So, we watch the getter and setter on `ReactCurrentDispatcher.current` to\n// monitor the changes to the current ReactDispatcher. When the dispatcher\n// changes from the ContextOnlyDispatcher to a \"valid\" dispatcher, we assume we\n// are entering a component render. At this point, we setup our\n// auto-subscriptions for any signals used in the component. We do this by\n// creating an Signal effect and manually starting the Signal effect. We use\n// `useSyncExternalStore` to trigger rerenders on the component when any signals\n// it uses changes.\n//\n// When the dispatcher changes from a valid dispatcher back to the\n// ContextOnlyDispatcher, we assume we are exiting a component render. At this\n// point we stop the effect.\n//\n// Some additional complexities to be aware of:\n// - If a component calls `setState` while rendering, React will re-render the\n//   component immediately. Before triggering the re-render, React will change\n//   the dispatcher to the HooksDispatcherOnRerender. When we transition to this\n//   rerendering adapter, we need to re-trigger our hooks to keep the order of\n//   hooks the same for every render of a component.\n//\n// - In development, useReducer, useState, and useMemo change the dispatcher to\n//   a different warning dispatcher (not ContextOnlyDispatcher) before invoking\n//   the reducer and resets it right after.\n//\n//   The useSyncExternalStore shim will use some of these hooks when we invoke\n//   it while entering a component render. We need to prevent this dispatcher\n//   change caused by these hooks from re-triggering our entering logic (it\n//   would cause an infinite loop if we did not). We do this by using a lock to\n//   prevent the setter from running while we are in the setter.\n//\n//   When a Component's function body invokes useReducer, useState, or useMemo,\n//   this change in dispatcher should not signal that we are entering or exiting\n//   a component render. We ignore this change by detecting these dispatchers as\n//   different from ContextOnlyDispatcher and other valid dispatchers.\n//\n// - The `use` hook will change the dispatcher to from a valid update dispatcher\n//   to a valid mount dispatcher in some cases. Similarly to useReducer\n//   mentioned above, we should not signal that we are exiting a component\n//   during this change. Because these other valid dispatchers do not pass the\n//   ContextOnlyDispatcher check, they do not affect our logic.\n//\n// - When server rendering, React does not change the dispatcher before and\n//   after each component render. It sets it once for before the first render\n//   and once for after the last render. This means that we will not be able to\n//   detect when we are entering or exiting a component render. This is fine\n//   because we don't need to detect this for server rendering. A component\n//   can't trigger async rerenders in SSR so we don't need to track signals.\n//\n//   If a component updates a signal value while rendering during SSR, we will\n//   not rerender the component because the signal value will synchronously\n//   change so all reads of the signal further down the tree will see the new\n//   value.\n\n/*\nBelow is a state machine definition for transitions between the various\ndispatchers in React's prod build. (It does not include dev time warning\ndispatchers which are just always ignored).\n\nENTER and EXIT suffixes indicates whether this ReactCurrentDispatcher transition\nsignals we are entering or exiting a component render, or if it doesn't signal a\nchange in the component rendering lifecyle (NOOP).\n\n```js\n// Paste this into https://stately.ai/viz to visualize the state machine.\nimport { createMachine } from \"xstate\";\n\n// ENTER, EXIT, NOOP suffixes indicates whether this ReactCurrentDispatcher\n// transition signals we are entering or exiting a component render, or\n// if it doesn't signal a change in the component rendering lifecyle (NOOP).\n\nconst dispatcherMachinePROD = createMachine({\n\tid: \"ReactCurrentDispatcher_PROD\",\n\tinitial: \"null\",\n\tstates: {\n\t\tnull: {\n\t\t\ton: {\n\t\t\t\tpushDispatcher: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tContextOnlyDispatcher: {\n\t\t\ton: {\n\t\t\t\trenderWithHooks_Mount_ENTER: \"HooksDispatcherOnMount\",\n\t\t\t\trenderWithHooks_Update_ENTER: \"HooksDispatcherOnUpdate\",\n\t\t\t\tpushDispatcher_NOOP: \"ContextOnlyDispatcher\",\n\t\t\t\tpopDispatcher_NOOP: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnMount: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnUpdate: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tuse_ResumeSuspensedMount_NOOP: \"HooksDispatcherOnMount\",\n\t\t\t},\n\t\t},\n\t\tHooksDispatcherOnRerender: {\n\t\t\ton: {\n\t\t\t\trenderWithHooksAgain_ENTER: \"HooksDispatcherOnRerender\",\n\t\t\t\tresetHooksAfterThrow_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t\tfinishRenderingHooks_EXIT: \"ContextOnlyDispatcher\",\n\t\t\t},\n\t\t},\n\t},\n});\n```\n*/\n\nexport let isAutoSignalTrackingInstalled = false;\n\nlet store: EffectStore | null = null;\nlet lock = false;\nlet currentDispatcher: ReactDispatcher | null = null;\n\nfunction installCurrentDispatcherHook() {\n\tisAutoSignalTrackingInstalled = true;\n\n\tObject.defineProperty(ReactInternals.ReactCurrentDispatcher, \"current\", {\n\t\tget() {\n\t\t\treturn currentDispatcher;\n\t\t},\n\t\tset(nextDispatcher: ReactDispatcher) {\n\t\t\tif (lock) {\n\t\t\t\tcurrentDispatcher = nextDispatcher;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst currentDispatcherType = getDispatcherType(currentDispatcher);\n\t\t\tconst nextDispatcherType = getDispatcherType(nextDispatcher);\n\n\t\t\t// Update the current dispatcher now so the hooks inside of the\n\t\t\t// useSyncExternalStore shim get the right dispatcher.\n\t\t\tcurrentDispatcher = nextDispatcher;\n\t\t\tif (\n\t\t\t\tisEnteringComponentRender(currentDispatcherType, nextDispatcherType)\n\t\t\t) {\n\t\t\t\tlock = true;\n\t\t\t\tstore = _useSignalsImplementation();\n\t\t\t\tlock = false;\n\t\t\t} else if (\n\t\t\t\tisExitingComponentRender(currentDispatcherType, nextDispatcherType)\n\t\t\t) {\n\t\t\t\tstore?.f();\n\t\t\t\tstore = null;\n\t\t\t}\n\t\t},\n\t});\n}\n\ntype DispatcherType = number;\nconst ContextOnlyDispatcherType = 1 << 0;\nconst WarningDispatcherType = 1 << 1;\nconst MountDispatcherType = 1 << 2;\nconst UpdateDispatcherType = 1 << 3;\nconst RerenderDispatcherType = 1 << 4;\nconst ServerDispatcherType = 1 << 5;\nconst BrowserClientDispatcherType =\n\tMountDispatcherType | UpdateDispatcherType | RerenderDispatcherType;\n\nconst dispatcherTypeCache = new Map<ReactDispatcher, DispatcherType>();\nfunction getDispatcherType(dispatcher: ReactDispatcher | null): DispatcherType {\n\t// Treat null the same as the ContextOnlyDispatcher.\n\tif (!dispatcher) return ContextOnlyDispatcherType;\n\n\tconst cached = dispatcherTypeCache.get(dispatcher);\n\tif (cached !== undefined) return cached;\n\n\t// The ContextOnlyDispatcher sets all the hook implementations to a function\n\t// that takes no arguments and throws and error. This dispatcher is the only\n\t// dispatcher where useReducer and useEffect will have the same\n\t// implementation.\n\tlet type: DispatcherType;\n\tconst useCallbackImpl = dispatcher.useCallback.toString();\n\tif (dispatcher.useReducer === dispatcher.useEffect) {\n\t\ttype = ContextOnlyDispatcherType;\n\n\t\t// @ts-expect-error When server rendering, useEffect and useImperativeHandle\n\t\t// are both set to noop functions and so have the same implementation.\n\t} else if (dispatcher.useEffect === dispatcher.useImperativeHandle) {\n\t\ttype = ServerDispatcherType;\n\t} else if (/Invalid/.test(useCallbackImpl)) {\n\t\t// We first check for warning dispatchers because they would also pass some\n\t\t// of the checks below.\n\t\ttype = WarningDispatcherType;\n\t} else if (\n\t\t// The development mount dispatcher invokes a function called\n\t\t// `mountCallback` whereas the development update/re-render dispatcher\n\t\t// invokes a function called `updateCallback`. Use that difference to\n\t\t// determine if we are in a mount or update-like dispatcher in development.\n\t\t// The production mount dispatcher defines an array of the form [callback,\n\t\t// deps] whereas update/re-render dispatchers read the array using array\n\t\t// indices (e.g. `[0]` and `[1]`). Use those differences to determine if we\n\t\t// are in a mount or update-like dispatcher in production.\n\t\t/updateCallback/.test(useCallbackImpl) ||\n\t\t(/\\[0\\]/.test(useCallbackImpl) && /\\[1\\]/.test(useCallbackImpl))\n\t) {\n\t\t// The update and rerender dispatchers have different implementations for\n\t\t// useReducer. We'll check it's implementation to determine if this is the\n\t\t// rerender or update dispatcher.\n\t\tlet useReducerImpl = dispatcher.useReducer.toString();\n\t\tif (\n\t\t\t// The development rerender dispatcher invokes a function called\n\t\t\t// `rerenderReducer` whereas the update dispatcher invokes a function\n\t\t\t// called `updateReducer`. The production rerender dispatcher returns an\n\t\t\t// array of the form `[state, dispatch]` whereas the update dispatcher\n\t\t\t// returns an array of `[fiber.memoizedState, dispatch]` so we check the\n\t\t\t// return statement in the implementation of useReducer to differentiate\n\t\t\t// between the two.\n\t\t\t/rerenderReducer/.test(useReducerImpl) ||\n\t\t\t/return\\s*\\[\\w+,/.test(useReducerImpl)\n\t\t) {\n\t\t\ttype = RerenderDispatcherType;\n\t\t} else {\n\t\t\ttype = UpdateDispatcherType;\n\t\t}\n\t} else {\n\t\ttype = MountDispatcherType;\n\t}\n\n\tdispatcherTypeCache.set(dispatcher, type);\n\treturn type;\n}\n\nfunction isEnteringComponentRender(\n\tcurrentDispatcherType: DispatcherType,\n\tnextDispatcherType: DispatcherType\n): boolean {\n\tif (\n\t\tcurrentDispatcherType & ContextOnlyDispatcherType &&\n\t\tnextDispatcherType & BrowserClientDispatcherType\n\t) {\n\t\t// ## Mount or update (ContextOnlyDispatcher -> ValidDispatcher (Mount or Update))\n\t\t//\n\t\t// If the current dispatcher is the ContextOnlyDispatcher and the next\n\t\t// dispatcher is a valid dispatcher, we are entering a component render.\n\t\treturn true;\n\t} else if (\n\t\tcurrentDispatcherType & WarningDispatcherType ||\n\t\tnextDispatcherType & WarningDispatcherType\n\t) {\n\t\t// ## Warning dispatcher\n\t\t//\n\t\t// If the current dispatcher or next dispatcher is an warning dispatcher,\n\t\t// we are not entering a component render. The current warning dispatchers\n\t\t// are used to warn when hooks are nested improperly and do not indicate\n\t\t// entering a new component render.\n\t\treturn false;\n\t} else if (nextDispatcherType & RerenderDispatcherType) {\n\t\t// Any transition into the rerender dispatcher is the beginning of a\n\t\t// component render, so we should invoke our hooks. Details below.\n\t\t//\n\t\t// ## In-place rerendering (e.g. Mount -> Rerender)\n\t\t//\n\t\t// If we are transitioning from the mount, update, or rerender dispatcher to\n\t\t// the rerender dispatcher (e.g. HooksDispatcherOnMount to\n\t\t// HooksDispatcherOnRerender), then this component is rerendering due to\n\t\t// calling setState inside of its function body. We are re-entering a\n\t\t// component's render method and so we should re-invoke our hooks.\n\t\treturn true;\n\t} else {\n\t\t// ## Resuming suspended mount edge case (Update -> Mount)\n\t\t//\n\t\t// If we are transitioning from the update dispatcher to the mount\n\t\t// dispatcher, then this component is using the `use` hook and is resuming\n\t\t// from a mount. We should not re-invoke our hooks in this situation since\n\t\t// we are not entering a new component render, but instead continuing a\n\t\t// previous render.\n\t\t//\n\t\t// ## Other transitions\n\t\t//\n\t\t// For example, Mount -> Mount, Update -> Update, Mount -> Update, any\n\t\t// transition in and out of invalid dispatchers.\n\t\t//\n\t\t// There is no known transition for the following transitions so we default\n\t\t// to not triggering a re-enter of the component.\n\t\t// - HooksDispatcherOnMount  -> HooksDispatcherOnMount\n\t\t// - HooksDispatcherOnMount  -> HooksDispatcherOnUpdate\n\t\t// - HooksDispatcherOnUpdate -> HooksDispatcherOnUpdate\n\t\treturn false;\n\t}\n}\n\n/**\n * We are exiting a component render if the current dispatcher is a valid\n * dispatcher and the next dispatcher is the ContextOnlyDispatcher.\n */\nfunction isExitingComponentRender(\n\tcurrentDispatcherType: DispatcherType,\n\tnextDispatcherType: DispatcherType\n): boolean {\n\treturn Boolean(\n\t\tcurrentDispatcherType & BrowserClientDispatcherType &&\n\t\t\tnextDispatcherType & ContextOnlyDispatcherType\n\t);\n}\n\ninterface JsxRuntimeModule {\n\tjsx?(type: any, ...rest: any[]): unknown;\n\tjsxs?(type: any, ...rest: any[]): unknown;\n\tjsxDEV?(type: any, ...rest: any[]): unknown;\n}\n\nexport function installJSXHooks() {\n\tconst JsxPro: JsxRuntimeModule = jsxRuntime;\n\tconst JsxDev: JsxRuntimeModule = jsxRuntimeDev;\n\n\t/**\n\t * createElement _may_ be called by jsx runtime as a fallback in certain cases,\n\t * so we need to wrap it regardless.\n\t *\n\t * The jsx exports depend on the `NODE_ENV` var to ensure the users' bundler doesn't\n\t * include both, so one of them will be set with `undefined` values.\n\t */\n\tReact.createElement = wrapJsx(React.createElement);\n\tJsxDev.jsx && /*   */ (JsxDev.jsx = wrapJsx(JsxDev.jsx));\n\tJsxPro.jsx && /*   */ (JsxPro.jsx = wrapJsx(JsxPro.jsx));\n\tJsxDev.jsxs && /*  */ (JsxDev.jsxs = wrapJsx(JsxDev.jsxs));\n\tJsxPro.jsxs && /*  */ (JsxPro.jsxs = wrapJsx(JsxPro.jsxs));\n\tJsxDev.jsxDEV && /**/ (JsxDev.jsxDEV = wrapJsx(JsxDev.jsxDEV));\n\tJsxPro.jsxDEV && /**/ (JsxPro.jsxDEV = wrapJsx(JsxPro.jsxDEV));\n}\n\nexport function installAutoSignalTracking() {\n\tinstallCurrentDispatcherHook();\n\tinstallJSXHooks();\n}\n", "import {\n\tsignal,\n\tcomputed,\n\teffect,\n\tSignal,\n\tReadonlySignal,\n} from \"@preact/signals-core\";\nimport { useRef, useMemo, useEffect } from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport { isAutoSignalTrackingInstalled } from \"./auto\";\n\nexport { installAutoSignalTracking } from \"./auto\";\n\nconst Empty = [] as const;\nconst ReactElemType = Symbol.for(\"react.element\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst noop = () => {};\n\nexport function wrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst symDispose: unique symbol =\n\t(Symbol as any).dispose || Symbol.for(\"Symbol.dispose\");\n\ninterface Effect {\n\t_sources: object | undefined;\n\t_start(): () => void;\n\t_callback(): void;\n\t_dispose(): void;\n}\n\nexport interface EffectStore {\n\teffect: Effect;\n\tsubscribe(onStoreChange: () => void): () => void;\n\tgetSnapshot(): number;\n\t/** finishEffect - stop tracking the signals used in this component */\n\tf(): void;\n\t[symDispose](): void;\n}\n\nlet finishUpdate: (() => void) | undefined;\n\nfunction setCurrentStore(store?: EffectStore) {\n\t// end tracking for the current update:\n\tif (finishUpdate) finishUpdate();\n\t// start tracking the new update:\n\tfinishUpdate = store && store.effect._start();\n}\n\nconst clearCurrentStore = () => setCurrentStore();\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the `effect._callback' is called,\n * we update our store version and tell React to re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://react.dev/reference/react/useSyncExternalStore\n * @see https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n */\nfunction createEffectStore(): EffectStore {\n\tlet effectInstance!: Effect;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\teffectInstance = this;\n\t});\n\teffectInstance._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\teffect: effectInstance,\n\t\tsubscribe(onStoreChange) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t\tf() {\n\t\t\tclearCurrentStore();\n\t\t},\n\t\t[symDispose]() {\n\t\t\tclearCurrentStore();\n\t\t},\n\t};\n}\n\nfunction createEmptyEffectStore(): EffectStore {\n\treturn {\n\t\teffect: {\n\t\t\t_sources: undefined,\n\t\t\t_callback() {},\n\t\t\t_start() {\n\t\t\t\treturn noop;\n\t\t\t},\n\t\t\t_dispose() {},\n\t\t},\n\t\tsubscribe() {\n\t\t\treturn noop;\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn 0;\n\t\t},\n\t\tf() {},\n\t\t[symDispose]() {},\n\t};\n}\n\nconst emptyEffectStore = createEmptyEffectStore();\n\nlet finalCleanup: Promise<void> | undefined;\nconst _queueMicroTask = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Custom hook to create the effect to track signals used during render and\n * subscribe to changes to rerender the component when the signals change.\n */\nexport function _useSignalsImplementation(): EffectStore {\n\tclearCurrentStore();\n\tif (!finalCleanup) {\n\t\tfinalCleanup = _queueMicroTask(() => {\n\t\t\tfinalCleanup = undefined;\n\t\t\tclearCurrentStore();\n\t\t});\n\t}\n\n\tconst storeRef = useRef<EffectStore>();\n\tif (storeRef.current == null) {\n\t\tstoreRef.current = createEffectStore();\n\t}\n\n\tconst store = storeRef.current;\n\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\tsetCurrentStore(store);\n\n\treturn store;\n}\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node or JSX.\n */\nfunction SignalValue({ data }: { data: Signal }) {\n\tconst store = useSignals();\n\ttry {\n\t\treturn data.value;\n\t} finally {\n\t\tstore.f();\n\t}\n}\n\n// Decorate Signals so React renders them as <SignalValue> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: SignalValue },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignals(): EffectStore {\n\tif (isAutoSignalTrackingInstalled) return emptyEffectStore;\n\treturn _useSignalsImplementation();\n}\n\nexport function useSignal<T>(value: T): Signal<T> {\n\treturn useMemo(() => signal<T>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T): ReadonlySignal<T> {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)): void {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => callback.current());\n\t}, Empty);\n}\n", "import {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuntracked,\n} from \"@preact/signals-core\";\nimport type { ReactElement } from \"react\";\nimport {\n\tuseSignal,\n\tuseComputed,\n\tuseSignalEffect,\n\tinstallAutoSignalTracking,\n} from \"../runtime/src/index\"; // TODO: This duplicates runtime code between main and sub runtime packages\n\nexport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n\tuseSignal,\n\tuseComputed,\n\tuseSignalEffect,\n\tuntracked,\n};\n\ndeclare module \"@preact/signals-core\" {\n\t// @ts-ignore internal Signal is viewed as function\n\t// eslint-disable-next-line @typescript-eslint/no-empty-interface\n\tinterface Signal extends ReactElement {}\n}\n\ninstallAutoSignalTracking();\n"],
  "mappings": "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",
  "names": ["x", "y", "error", "cycleDetected", "Error", "identifier", "Symbol", "endBatch", "batchDepth", "error", "hasError", "batchedEffect", "effect", "batchIteration", "next", "_nextBatchedEffect", "_flags", "needsToRecompute", "_callback", "err", "batch", "callback", "evalContext", "untrackedDepth", "untracked", "prevContext", "globalVersion", "addDependency", "signal", "node", "_node", "_target", "_version", "_source", "_prevSource", "_sources", "_nextSource", "_prevTarget", "_nextTarget", "_rollbackNode", "_subscribe", "Signal", "value", "this", "_value", "_targets", "prototype", "brand", "_refresh", "_unsubscribe", "prev", "subscribe", "fn", "flag", "valueOf", "toString", "toJSON", "peek", "Object", "defineProperty", "get", "set", "Computed", "mutationDetected", "_notify", "target", "prepareSources", "rollbackNode", "cleanupSources", "head", "compute", "call", "undefined", "_compute", "_globalVersion", "OUTDATED", "computed", "cleanupEffect", "cleanup", "_cleanup", "disposeEffect", "endEffect", "Effect", "finish", "_start", "bind", "_dispose", "isAutoSignalTrackingInstalled", "store", "lock", "currentDispatcher", "dispatcherTypeCache", "Map", "getDispatcherType", "dispatcher", "type", "cached", "get", "useCallbackImpl", "useCallback", "toString", "useReducer", "useEffect", "useImperativeHandle", "test", "useReducerImpl", "set", "Empty", "ReactElemType", "Symbol", "noop", "wrapJsx", "jsx", "props", "i", "v", "Signal", "value", "call", "apply", "concat", "slice", "arguments", "finishUpdate", "symDispose", "dispose", "setCurrentStore", "effect", "_start", "_ref2", "finalCleanup", "clearCurrentStore", "emptyEffectStore", "_sources", "_callback", "_dispose", "subscribe", "getSnapshot", "f", "_queueMicroTask", "Promise", "prototype", "then", "bind", "resolve", "_useSignalsImplementation", "storeRef", "useRef", "current", "_ref", "effectInstance", "onChangeNotifyReact", "version", "unsubscribe", "this", "onStoreChange", "createEffectStore", "useSyncExternalStore", "Object", "defineProperties", "$$typeof", "configurable", "_ref3", "data", "useSignals", "ref", "useSignal", "useMemo", "signal", "useComputed", "compute", "$compute", "computed", "useSignalEffect", "cb", "callback", "defineProperty", "ReactInternals", "ReactCurrentDispatcher", "nextDispatcher", "currentDispatcherType", "nextDispatcherType", "MountDispatcherType", "Boolean", "_store", "installCurrentDispatcherHook", "JsxPro", "jsxRuntime", "JsxDev", "jsxRuntimeDev", "React", "createElement", "jsxs", "jsxDEV", "installJSXHooks", "installAutoSignalTracking"]
}
